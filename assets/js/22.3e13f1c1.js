(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{516:function(e,r,t){"use strict";t.r(r);var s=t(6),a=Object(s.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A",target:"_blank",rel:"noopener noreferrer"}},[e._v("SSL"),t("OutboundLink")],1),e._v("（Secure Socket Layer）安全套接层，是一种位于应用层与传输层之间，为网络通信提供安全及完整性验证的一种网络协议。")]),e._v(" "),t("p",[e._v("相对于TCP或HTTP协议，SSL协议要复杂很多。由于它也是建立在TCP协议之上的，所以在使用SSL传输数据之前需要先进行三次握手和服务器建立连接，具体的流程如图所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/5/6/1633532f95052afd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),t("h2",{attrs:{id:"ssl协议的握手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssl协议的握手过程"}},[e._v("#")]),e._v(" SSL协议的握手过程")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("客户端先给服务端发送一个消息，消息内容包括：客户端支持的加密方式，支持的压缩方法，SSL的版本号，客户端生成的随机数，文本内容“Hello”等；")])]),e._v(" "),t("li",[t("p",[e._v("服务端接收到消息后，也回发一个Hello，并携带从客户端支持的加密方式中选择的加密方式，服务端生成的随机数，服务端的SSL版本号等信息；")])])]),e._v(" "),t("blockquote",[t("p",[e._v("1 - 2: 协商加密算法以及传输各自生成的随机数（为后续生成master secret做准备）的过程")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("随后服务器给客户端发送一个Certificate报文，报文中包含服务端的公钥证书；")])]),e._v(" "),t("blockquote",[t("p",[e._v("3: 服务端将自己的证书发送给客户端，这个证书中包含一个数字签名（CA签名）和服务端CA证书的公钥，客户端对证书中包含的服务端信息进行Hash, 同时使用接收到的公钥对数字证书解密，获取其中的Hash值，与前面计算得到的Hash值进行比较，即可验证证书的有效性（完整性&真实性）；")])]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("p",[e._v("紧接着服务器给客户端发送Server Hello Done, 表示最初的协商握手过程结束；")])]),e._v(" "),t("li",[t("p",[e._v("客户端接收到服务端发送的握手结束的消息后，以Client Key Exchange作为回应，此报文中包含通信加密过程中使用的一种被称为Pre-master secret的随机密码串，并使用第三步接收到的公钥证书进行了加密；")])])]),e._v(" "),t("blockquote",[t("p",[e._v("服务端收到客户端发送的Change Cipher Spec,会使用自己的私钥进行解密，获取报文中的Pre-master secret，这时通信双方都拥有对方的Random(前两步生成的)，Pre-master secret，以及自身的Random, 将三个数作为种子通过算法生成master secret, 用来加密后续Http请求过程中的数据。其中master secret的生成规则为:")]),e._v(" "),t("p",[e._v("master_secret = MD5(pre_master_secret + SHA('A' + pre_master_secret + ClientHello.random + ServerHello.random)) + MD5(pre_master_secret + SHA('BB' + pre_master_secret + ClientHello.random + ServerHello.random)) + MD5(pre_master_secret + SHA('CCC' + pre_master_secret + ClientHello.random + ServerHello.random));")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://tools.ietf.org/html/rfc6101#section-5.7",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 6101 SSL"),t("OutboundLink")],1)])]),e._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[t("p",[e._v("接着客户端发送Change Cipher Spec报文，该报文告知服务端，此步骤之后的所有数据将使用第五步中生成的master secret进行加密（master secret的生成过程看后面的介绍）；")])]),e._v(" "),t("li",[t("p",[e._v("随后客户端发送Finish报文，此报文中包含连接至今所有报文的整体校验值，用于完整性验证；")])]),e._v(" "),t("li",[t("p",[e._v("服务端接收到客户端发送的Change Cliper Spec报文后，同样以Change Cliper Spec报文作为回应；")])]),e._v(" "),t("li",[t("p",[e._v("接着服务端发送Finish报文给客户端，表示服务端已正确解析客户端发送的整体校验值，至此，SSL握手的过程结束。")])]),e._v(" "),t("li",[t("p",[e._v("随后开始使用HTTP协议传输使用master secret加密过的数据。")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);